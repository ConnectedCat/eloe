package  {	import com.adobe.images.PNGEncoder;	import flash.geom.*;	import flash.display.*;	import flash.events.*;//for event handling	import flash.net.Socket;//Sockets	import flash.utils.*;	import flash.text.*;	import flash.net.*;	import flash.system.*;	import com.adobe.serialization.json.*;//as3corelib JSON support	import fl.transitions.*;		import org.tuio.osc.OSCManager;	import org.tuio.ITuioListener;	import org.tuio.TuioBlob;	import org.tuio.TuioClient;	import org.tuio.TuioCursor;	import org.tuio.TuioObject;	import org.tuio.connectors.LCConnector;	import com.bit101.components.Text;		public class MultiTouchEloe extends MovieClip implements ITuioListener{		/* Pencil Tool shape, everything drawn with this tool and the eraser tool is stored inside board.pencilDraw */		var pencilDraw:Shape = new Shape();		/* Colors */		var colorsBmd:BitmapData;//We'll use this Bitmap Data to get the pixel RGB Value when clicked		var pixelValue:uint;		var activeColor:uint = 0x000000;//This is the current color in use, displayed by the shapeSize MC		/* Save dialog instance */		var saveDialog:SaveDialog;		/* Active var, to check which tool is active */		var active:String;		/* Shape size color */		var ct:ColorTransform = new ColorTransform();		var colorInd:Shape = new Shape();		var conFormat:TextFormat = new TextFormat();				public var lines:Array;		public var attention:uint;		public var meditation:uint;		public var poorSignal:uint;		public var color:uint;		public var thickness:uint;		private var thinkGearSocket:Socket;				public static const TILT_MODE : int = 4;		public static const SEND_DATA_SIZE : int = 6;				protected var client : TuioClient;		protected var connectionNameIn : String = "_OscDataStream";		protected var connectionNameOut : String = "_OscDataStreamOut";		protected var lcConnector : LCConnector;		protected var oscManager : OSCManager;				public function MultiTouchEloe() {			fscommand("fullscreen", "true");            fscommand("allowscale", "true");			// constructor code			thinkGearSocket = new Socket  ;			thinkGearSocket.addEventListener(ProgressEvent.SOCKET_DATA,dataHandler);						//TUIO connection			lcConnector = new LCConnector(connectionNameIn, connectionNameOut);			client = new TuioClient(lcConnector);			client.addListener(this);			oscManager = new OSCManager(null, lcConnector);			oscManager.start();			//end TUIO connection						lines = new Array();						/* We create these functions later */			addListeners();			/* Hide tools highlights */			pencil.visible = false;			hideTools(eraser);						connectButton.addEventListener(MouseEvent.CLICK,                                     function(e : Event){                                       if(thinkGearSocket.connected){                                         disconnectSocket();                                         connectButton.label = "Connect";										 connectButton2.label = "Connect";                                       }                                       else {                                         connectSocket();                                         connectButton.label = "Disconnect";										 connectButton2.label = "Disconnect";                                       }                                     });			connectButton2.addEventListener(MouseEvent.CLICK,                                     function(e : Event){                                       if(thinkGearSocket.connected){                                         disconnectSocket();                                         connectButton.label = "Connect";										 connectButton2.label = "Connect";                                       }                                       else {                                         connectSocket();                                         connectButton.label = "Disconnect";										 connectButton2.label = "Disconnect";                                       }                                     });									 					}//end constructor				public function addTuioCursor(tuioCursor : TuioCursor) : void		{			switch (active)			{				case "Pencil" :					lines[tuioCursor.sessionID.toString()] = new Shape();//We add a new shape to draw always in top (in case of text, or eraser drawings)					board.addChild(lines[tuioCursor.sessionID.toString()]);					lines[tuioCursor.sessionID.toString()].graphics.moveTo(tuioCursor.x * board.width, tuioCursor.y * board.height);					lines[tuioCursor.sessionID.toString()].graphics.lineStyle(thickness, color);					new Ring(tuioCursor.sessionID.toString(), this, tuioCursor.x * board.width, tuioCursor.y * board.height, 10);					break;				case "Eraser" :					lines[tuioCursor.sessionID.toString()] = new Shape();//We add a new shape to draw always in top (in case of text, or eraser drawings)					board.addChild(lines[tuioCursor.sessionID.toString()]);					lines[tuioCursor.sessionID.toString()].graphics.moveTo(tuioCursor.x * board.width, tuioCursor.y * board.height);					lines[tuioCursor.sessionID.toString()].graphics.lineStyle(20, 0xFFFFFF);					new Ring(tuioCursor.sessionID.toString(), this, tuioCursor.x * board.width, tuioCursor.y * board.height, 10);					break;				default :					break;			}		}		public function updateTuioCursor(tuioCursor : TuioCursor) : void		{			try			{				var ring : Ring = getChildByName(tuioCursor.sessionID.toString()) as Ring;				ring.moveTo(tuioCursor.x * board.width, tuioCursor.y * board.height);				if(active == "Pencil"){lines[tuioCursor.sessionID.toString()].graphics.lineStyle(thickness, color);}				lines[tuioCursor.sessionID.toString()].graphics.lineTo(ring.x, ring.y);			}			catch (e:Error)			{			}		}		public function removeTuioCursor(tuioCursor : TuioCursor) : void		{			try			{				var ring : Ring = getChildByName(tuioCursor.sessionID.toString()) as Ring;				ring.destroy();			}			catch(e : Error)			{			}		}				public function addTuioObject(tuioObject : TuioObject) : void		{		}		public function updateTuioObject(tuioObject : TuioObject) : void		{		}		public function removeTuioObject(tuioObject : TuioObject) : void		{		}		public function addTuioBlob(tuioBlob : TuioBlob) : void		{		}		public function updateTuioBlob(tuioBlob : TuioBlob) : void		{		}		public function removeTuioBlob(tuioBlob : TuioBlob) : void		{		}		public function newFrame(id : uint) : void		{		}				private function connectSocket(){			thinkGearSocket.connect("127.0.0.1",13854);						var configuration:Object = new Object  ;			configuration["enableRawOutput"] = false;			configuration["format"] = "Json";						thinkGearSocket.writeUTFBytes(JSON.encode(configuration));		}				private function disconnectSocket(){			thinkGearSocket.close();			label1.visible = false;			connectedText.visible = false;			colorInd.graphics.beginFill(0x758792, 1);			removeChild(colorInd);		}				private function dataHandler(e:ProgressEvent)		{			var packetString:String = thinkGearSocket.readUTFBytes(thinkGearSocket.bytesAvailable);			thinkGearSocket.flush();			var packets:Array = packetString.split(/\r/);			var data:Object;			for each (var packet:String in packets)			{				if ((packet != ""))				{					try					{						data = JSON.decode(packet);					}					catch (jError:JSONParseError)					{						//do error handling here					}					if (data["poorSignalLevel"] != null)					{						poorSignal = data["poorSignalLevel"];						if ((poorSignal < 100))						{							label1.visible = true;							connectedText.visible = true;							connectedText.text = "GOOD CONNECTION";							conFormat.color = 0x00FF00;							connectedText.setTextFormat(conFormat);							addChild(colorInd);							attention = data["eSense"]["attention"];							meditation = data["eSense"]["meditation"];							//trace("Attention :" + attention + "\nMeditation :" + meditation);							thickness = map(attention, 0, 100, 30, 3);							color = map(meditation, 0, 100, 0x000000, 0xFFFFFF);							//trace("Thickness :" + thickness + "\nColor :" + color);							label1.text = "Attention: " + attention.toString() + "\nMeditation: " + meditation.toString() + "\nThickness: " + thickness.toString() + "\nColor: ";							drawColorIndicator();						}//end if(poorSignal == 0)						else{							connectedText.text = "POOR CONNECTION";							conFormat.color = 0xAA0000;							connectedText.setTextFormat(conFormat);						}					}				}				data = null;			}/*for each*/		}/*function dataHandler*/		private function drawColorIndicator():void{			colorInd.graphics.beginFill(color, 1);			colorInd.graphics.drawRect(1075, 416, 40, 15);		}		private function PencilTool(e:MouseEvent):void		{			if(active == "Pencil"){				active = "";				hideTools(pencil);			}			else{				active = "Pencil";				highlightTool(pencil);				hideTools(eraser);			}		}		private function EraserTool(e:MouseEvent):void		{			if(active == "Eraser"){				active = "";				hideTools(eraser);			}			else{				active = "Eraser";				highlightTool(eraser);				hideTools(pencil);			}		}		private function export():void		{			var bmd:BitmapData = new BitmapData(board.width,board.height);//Creates a new BitmapData with the board size			bmd.draw(board);			//Draws the board MovieClip into a BitmapImage in the BitmapData;			var ba:ByteArray = PNGEncoder.encode(bmd);//Creates a ByteArray of the BitmapData, encoded as PNG			var file:FileReference = new FileReference();// Instantiates a new File Reference Object to handle the save			file.addEventListener(Event.COMPLETE, saveSuccessful);			var now:Date = new Date();			//Adds a new listener to listen when the save is complete;			file.save(ba, "MyDrawing" + now.month.toString() + now.day.toString() + now.hours.toString() + now.minutes.toString() +now.seconds.toString() + ".png");		}		//Saves the ByteArray as a PNG;		private function saveSuccessful(e:Event):void		{			saveDialog = new SaveDialog();// Instantiates a new SaveDialog Class			addChild(saveDialog);//Adds the SaveDialog MovieClip to the Stage			saveDialog.closeBtn.addEventListener(MouseEvent.MOUSE_UP, closeSaveDialog);		}		//Adds a listener to the close button of the dialog;		private function closeSaveDialog(e:MouseEvent):void		{			removeChild(saveDialog);//Removes the dialog of the Stage		}		private function save(e:MouseEvent):void		{			export();//Calls the export function to begin the saving process		}		private function clearBoard(e:MouseEvent):void		{			/* Create a white rectangle on top of everything */			var blank:Shape = new Shape();						blank.graphics.beginFill(0xFFFFFF);			blank.graphics.drawRect(0, 0, board.width, board.height);			blank.graphics.endFill();			board.addChild(blank);		}				private function highlightTool(tool:DisplayObject):void		{			tool.visible = true;//Highlights tool in the parameter		}		private function hideTools(tool1:DisplayObject):void		{			tool1.visible = false;		}		private function map(v:Number,a:Number,b:Number,x:Number=0,y:Number=1):Number		{			return (v == a) ? x:(v - a) * (y - x) / (b - a) + x;		}//map(value, low1, high1, low2, high2)		private function randomNumber(low:Number=0, high:Number=1):Number		{			return Math.floor(Math.random() * (1+high-low)) + low;		}		private function addListeners():void		{    		pencilTool.addEventListener(MouseEvent.MOUSE_UP, PencilTool);    		eraserTool.addEventListener(MouseEvent.MOUSE_UP, EraserTool);    		saveButton.addEventListener(MouseEvent.MOUSE_UP, save);    		clearTool.addEventListener(MouseEvent.MOUSE_UP, clearBoard);		}	}//end class	}//end package